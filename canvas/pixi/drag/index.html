<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title></title>
    <style>
        canvas {
            border: 1px dashed gray;
        }
        #results, #container {
            display: inline-block;
            margin: 15px;
        }
        p {
            margin: 15px;
        }
        td {
            border: 1px solid #bbb;
        }
        .header {
            font-weight: bold;
        }
    </style>
</head>
<body>
<p id="user-agent"></p>
<div id="container"></div>
<table id="results">
    <tr class="header">
        <td>Circles</td>
        <td>FPS</td>
        <td>repaint [ms]</td>
    </tr>
</table>
<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/3.0.7/pixi.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tinycolor/1.1.2/tinycolor.min.js"></script>
<script src="https://gitcdn.xyz/repo/cool-Blue/d3-lib/master/filters/shadow.js"></script>
<div id="log1"></div>
<div id="log2"></div>
<script>
    $(function (){
        /* global requestAnimationFrame, $, PIXI, canvg */
        window.requestAnimationFrame = (function() {
            return window.requestAnimationFrame ||
                window.webkitRequestAnimationFrame ||
                window.mozRequestAnimationFrame ||
                window.oRequestAnimationFrame ||
                window.msRequestAnimationFrame ||
                function(/* function FrameRequestCallback */ callback, /* DOMElement Element */ element) {
                    return window.setTimeout(callback, 1000/60);
                };
        })();
        var tests = [250, 500, 750, 1000, 2000, 5000];
        function updateResults(count, time, steps) {
            var repaint = time / steps,
                $tr = $("<tr>");
            $tr.append("<td>" + count + "</td><td>" + (1000/repaint).toFixed(2) + "</td><td>" + repaint.toFixed(2) + "</td>");
            $("#results").append($tr);
        }
        function test() {
            var count,
                maxX = 500,
                maxY = 400,
                maxSteps = 300,
                steps = 0,
                renderer,
                stage,
                container,
                ctx,
                circleCanvas,
                circleTexture,
                circles = [],
                cdata = [],
                startTime,
                circle,
                i;
            if (tests.length > 0) {
                $("#container").empty();
                count = tests.shift();
            } else {
                return;
            }
            var x = d3.scale.linear()
                    .range([0, maxX])
                    .domain([0, maxX * 1]),
                y = d3.scale.linear()
                    .range([0, maxY])
                    .domain([0, maxY]),
                c20 = d3.scale.category20(),
                col = d3.range(20).map(function(c){
                    return c20(c).replace("#", "0x")
                }),
                species;

            // set up webgl
            renderer = new PIXI.autoDetectRenderer(maxX, maxY);
            $("#container").append(renderer.view);
            ctx = renderer.view.getContext('webgl');
            stage = new PIXI.Container();
            renderer.backgroundColor = +("0x" + tinycolor("white").toHex());

            // make sprite
            circleCanvas = document.createElement("canvas");
            //        canvg(circleCanvas, "circle.svg");
            filters.cSphere(circleCanvas.getContext("2d"), 16, 16, 16);
            // workaround: without removing cached textures creating a new texture
            // will use cached texture from old WebGL context.
            circleTexture = new PIXI.Texture.fromCanvas(circleCanvas);
//            circleTexture.baseTexture.scaleMode = PIXI.SCALE_MODES.NEAREST;

            for (i = 0; i < count; i++) {
                circle = {
                    x: x.invert(maxX * Math.random()),
                    y: y.invert(maxY * Math.random()),
                    r: 16 * (species = Math.round(Math.random())/2 + 0.5),
                    vx: Math.random(),
                    vy: Math.random()
                };
                cdata.push(circle);
                circle = new PIXI.Sprite(circleTexture);
                circle.anchor.set(0.5);
//                circle.scale.set(species);
                circle.tint = +col[Math.round(species*19)];
                circles.push(circle);
                stage.addChild(circle);
            }
            ctx.shadowColor = "steelblue";
            ctx.shadowOffsetX = 6; ctx.shadowOffsetY = 6; ctx.shadowBlur = 9;
            // Start animation.
            startTime = new Date().getTime();
            requestAnimationFrame(step);
            function step() {
                var i, len, c, r, time;
                for (i = 0, len = count; i < len; i++) {
                    var s = circles[i].scale;
                    c = cdata[i]; r = c.r;
                    if (x(c.x) >= (maxX - r) || x(c.x) <= r) c.vx *= -1;
                    if (y(c.y) >= (maxY - r) || y(c.y) <= r) c.vy *= -1;
                    c.x += c.vx;
                    c.y += c.vy;
                    circles[i].position.x = c.x;
                    circles[i].position.y = c.y;
                }
                renderer.render(stage);
                if (steps < maxSteps) {
                    steps++;
                    requestAnimationFrame(step);
                } else {
                    time = new Date().getTime() - startTime;
                    updateResults(count, time, maxSteps);
                    test();
                }
            }
        }
        $(function () {
            $("#user-agent").text(navigator.userAgent);
            test();
        });
    })
</script>
</body>
</html>