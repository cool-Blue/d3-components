<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title></title>
  <style>
    svg {
      outline: 1px solid red;
      overflow: visible;
    }
    .axis path {
      stroke: #ccc;
    }

    .axis line {
      stroke: #ccc;
      stroke-opacity: .5;
    }
    .axis path {
      fill: none;
    }
    .axis text {
      font-size: 8px;
    }
    .datum {
      /*fill: url(#filter-bubble-green-white);*/
      fill: url(#filter-spherical-shading-black-white);
      opacity: 1;
      -webkit-filter: drop-shadow(10px 5px 5px blue);
    }
    /*.datum.visible {*/
      /*fill: url(#filter-spherical-shading);*/
    /*}*/
  </style>
</head>
<body>
<script src="d3 CB.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/tinycolor/1.1.2/tinycolor.min.js"></script>
<script src="filters/shadow.js"></script>
<script>
  var size = 500, r = 1.75;

  var margin = {top: 30, right: 40, bottom: 30, left: 50},
    width = 600 - margin.left - margin.right,
    height = 200 - margin.top - margin.bottom;

  var dataSet = d3.range(10000).map(function(d, idx) {
    return {
      x: d3.random.normal(100 / 2, 100 / 4)(),
      y: d3.random.normal(100 / 2, 100 / 4)(),
      uuid: idx
    };
  });

  var quadtree = d3.geom.quadtree(dataSet);

  //------------------------- DOM Manipulation -------------------------
  function graph(selector, Owner){
    //
    // Init Scales
    //

    var xScale = d3.scale.linear()
      .domain([0, 100])
      .range([0, width])
      .nice(10);

    var yScale = d3.scale.linear()
      .domain([0, 100])
      .range([height, 0])
      .nice(10);

    //
    // Init Axes
    //

    var xAxis = d3.svg.axis()
      .scale(xScale)
      .ticks(10)
      .orient("bottom")
      .tickSize(-height);

    var yAxis = d3.svg.axis()
      .scale(yScale)
      .ticks(10)
      .orient("left")
      .tickSize(-width);

    //
    // Init Zoom
    //

    var d3Zoom = d3.behavior.zoom()
      .x(xScale)
      .y(yScale)
      .scaleExtent([0.99, Infinity])
      .on("zoom", onZoom)
    //    .on("zoomend", updateSelection);

    var root = d3.select(selector).append("svg")
        .attr("width", width + margin.left + margin.right)
        .attr("height", height + margin.top + margin.bottom),

        svg = root.append("g")
        .attr("class", "data_container")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
        .call(d3Zoom),

        plotSurface = svg.append("rect")
        .attr("class", "overlay")
        .attr("width", width)
        .attr("height", height)
        .style({"fill": "none", opacity: 0.8})
        .style("pointer-events", "all"),

        clipRect = svg.append("clipPath")
        .attr("id", "clip")
        .append("rect")
        .attr("width", width)
        .attr("height", height),

        circles = svg.append("g")
        .style("filter", filters.drop(svg))
        .attr({"clip-path": "url(#clip)"}),

        owner = Owner({root: root, xScale: xScale, yScale: yScale }),

        bubble = Bubble(root);

    d3Zoom.xAxis = svg.insert("g", function(){return circles.node()})            // Add the X Axis
        .attr("class", "x axis")
        .attr("transform", "translate(0," + height + ")")
        .call(xAxis);

    d3Zoom.yAxis = svg.insert("g", function(){return circles.node()})
        .attr("class", "y axis")
        .call(yAxis);

    owner.draw(circles);

    onZoom();

    function onZoom() {

      //
      // Store zoom extent
      //

      d3Zoom.extent = [
        [xScale.invert(0), yScale.invert(height)],
        [xScale.invert(width), yScale.invert(0)]
      ];
      d3Zoom.scaleFactor = d3.event && d3.event.scale ? d3.event.scale : 1;
      d3Zoom.translation = d3.event && d3.event.translate ? d3.event.translate : [0, 0];

      //
      // Update some heavy duty stuff
      // (create a quadtree, search that quadtree and update an attribute for the elements found)
      //

      // Prune non visible data
      owner.redraw(search(quadtree, d3Zoom.extent), circles);

      //
      // Update axes
      //

      d3Zoom.xAxis.call(xAxis);
      d3Zoom.yAxis.call(yAxis);

    }

  }

  var minNodes = function(config) {

    var fill = filters.sphere(config.root, "black");
    function drawCircles(circles) {
      redraw((fill.map ? dataSet.map(fill.map) : dataSet), circles)
    }
    function redraw(subset, circles) {

      // Attach new data
      // keep the original order for object constancy
      var elements = circles.selectAll("circle").data(subset.sort(function compareNumbers(a, b) {
        return a.uuid - b.uuid;
      }), function(d) {
        return d.uuid;
      });

      //enter

      elements.enter().append("circle").style("fill", fill).attr("class", "datum").attr("r", r);

      //exit

      elements.exit().remove();

      //update
      updateSelection(elements);

      function updateSelection(elements) {
        // some not so heavy duty stuff
        elements.order().attr("transform", scaleData);
      }

      function scaleData(d) {
        return "translate(" + [config.xScale(d.x), config.yScale(d.y)] + ")";
      }

    }
    return {
      draw: drawCircles,
      redraw: redraw
    }
  }

  graph("body", minNodes);

  function Bubble(svg){
    var colors = d3.range(20).map(d3.scale.category20()).map(function(d){
      return filters.sphere(svg, d)
    });
    return {
      call: function(selection){
      selection.style("fill", function(){
        return colors[~~(Math.random()*20)]
      })
    },
      map: function(d, i, data){
        d.fill = colors[~~(Math.random()*20)];
      },
      fill: function(d){return d.fill}
    }
  };

  //------------------------ Callbacks --------------------------------

  //
  // search quadtree
  //

  function search(qt, extent) {
    var pts = [],
        x0=extent[0][0], y0=extent[0][1],
        x3=extent[1][0], y3=extent[1][1];
    qt.visit(function(node, x1, y1, x2, y2) {
      var p = node.point;

      if ((p) && (p.x >= x0) && (p.x <= x3) && (p.y >= y0) && (p.y <= y3)) {
        pts.push(p);
      }

      return x1 >= x3 || y1 >= y3 || x2 < x0 || y2 < y0;
    });

    return pts;
  }

</script>

</body>
</html>