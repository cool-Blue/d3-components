<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title></title>
  <style>
    svg {
      outline: 1px solid red;
      overflow: visible;
    }
    .axis path {
      stroke: #ccc;
    }

    .axis line {
      stroke: #ccc;
      stroke-opacity: .5;
    }
    .axis path {
      fill: none;
    }
    .axis text {
      font-size: 8px;
    }
    .datum {
      /*fill: none;*/
      opacity: 0;
    }
    .datum.visible {
      /*fill: url(#filter-spherical-shading);*/
      opacity: 1;
    }
    /*#clipButton {*/
      /*position: absolute;*/
    /*}*/
  </style>
</head>
<body>
<script src="d3 CB.js"></script>
<!--<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/tinycolor/1.1.2/tinycolor.min.js"></script>
<script src="filters/shadow.js"></script>
<script>
  var size = 500, r = 1.75;

  var margin = {top: 30, right: 40, bottom: 30, left: 50},
    width = 600 - margin.left - margin.right,
    height = 200 - margin.top - margin.bottom;

  var dataSet = d3.range(10000).map(function(d, idx) {
    return {
      x: d3.random.normal(100 / 2, 100 / 4)(),
      y: d3.random.normal(100 / 2, 100 / 4)(),
      uuid: idx
    };
  });

  //
  // Init Scales
  //

  var xScale = d3.scale.linear()
      .domain([0, 100])
      .range([0, width])
      .nice(10);

  var yScale = d3.scale.linear()
    .domain([0, 100])
    .range([height, 0])
    .nice(10);

  //
  // Init Axes
  //

  var xAxis = d3.svg.axis()
    .scale(xScale)
    .ticks(10)
    .orient("bottom")
    .tickSize(-height);

  var yAxis = d3.svg.axis()
    .scale(yScale)
    .ticks(10)
    .orient("left")
    .tickSize(-width);

  //
  // Init Zoom
  //

  var d3Zoom = d3.behavior.zoom()
    .x(xScale)
    .y(yScale)
    .scaleExtent([0.99, Infinity])
    .on("zoom", semanticZoom)
//    .on("zoomend", updateSelection);

  var quadtree = d3.geom.quadtree(dataSet);

  //------------------------- DOM Manipulation -------------------------

  var svg = d3.select("body").append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
      .append("g")
      .attr("class", "data_container")
      .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
      .call(d3Zoom),

    plotSurface = svg.append("rect")
      .attr("class", "overlay")
      .attr("width", width)
      .attr("height", height)
      .style({"fill": "none"})
      .style("pointer-events", "all"),

    gX = svg.append("g")            // Add the X Axis
      .attr("class", "x axis")
      .attr("transform", "translate(0," + height + ")")
      .call(xAxis),

    gY = svg.append("g")
      .attr("class", "y axis")
      .call(yAxis),

    clipRect = svg.append("clipPath")
      .attr("id", "clip")
      .append("rect")
      .attr("width", width)
      .attr("height", height),

    spherical = filters.sphere(svg, "green"),
    bubble = Bubble(svg);

  var circles = svg.append("g")
      .style("filter", filters.drop(svg))
      .attr({"clip-path": "url(#clip)"}),

  circle = drawCircles(dataSet, circles);

  semanticZoom();

  function drawCircles(dataSet, circles) {
    var circle = circles
      .selectAll("circle")
      .data(dataSet, function(d) {
        return d.uuid;
      });

    circle.enter().append("circle")
      .attr("r", r)
      .attr("class", "datum")
      .attr("transform", ScaleData)
      .call(bubble.call);
    return circle;
  }

  function Bubble(svg){
    var colors = d3.range(20).map(d3.scale.category20b()).map(function(d){
      return filters.sphere(svg, d)
    });
    return {
      call: function(selection){
        selection.style("fill", function(){
          return colors[~~(Math.random()*20)]
        })
      },
      map: function(d, i, data){
        d.fill = colors[~~(Math.random()*20)];
      },
      fill: function(d){return d.fill}
    }
  };

  //------------------------ Callbacks --------------------------------

  function semanticZoom() {

    var s = 1;
    var t = [0, 0];
    if (d3.event) {
      s = (d3.event.scale) ? d3.event.scale : 1;
      t = (d3.event.translate) ? d3.event.translate : [0, 0];
    }

    var tl = [xScale.invert(0), yScale.invert(height)];
    var br = [xScale.invert(width), yScale.invert(0)];

    //
    // Store zoom extent
    //

    d3Zoom.extent = [tl, br];
    d3Zoom.scaleFactor = s;
    d3Zoom.translation = t;

    //
    // Update some heavy duty stuff
    // (create a quadtree, search that quadtree and update an attribute for the elements found)
    //

    // Prune non visible data
    redraw(search(quadtree, d3Zoom.extent), circle);

    //
    // Update axes
    //

    d3.select(".x.axis").call(xAxis);
    d3.select(".y.axis").call(yAxis);

  };
  function redraw(data, circle){

    markSubset(data, circle);
    updateSelection(circle);

    function markSubset(data, nodes){
      var marked = nodes.data(data, function(d){return d.uuid;});
      marked.enter();
      marked.classed("visible", true)
      marked.exit().classed("visible", false)
    }
    function updateSelection(elements) {
      // some not so heavy duty stuff
      elements
        .select(function(){
          return d3.select(this)
            .classed("visible") ? this : null;})
        .attr("transform", ScaleData);

    }
  }
  function ScaleData(d) {
    return "translate(" + [xScale(d.x), yScale(d.y)] + ")";
  }

  //
  // search quadtree
  //

  function search(qt, extent) {
    var pts = [],
        x0=extent[0][0], y0=extent[0][1],
      x3=extent[1][0], y3=extent[1][1];
    qt.visit(function(node, x1, y1, x2, y2) {
      var p = node.point;

      if ((p) && (p.x >= x0) && (p.x <= x3) && (p.y >= y0) && (p.y <= y3)) {
        pts.push(p);
      }

      return x1 >= x3 || y1 >= y3 || x2 < x0 || y2 < y0;
    });

    return pts;
  }

</script>
</body>
</html>