function regularPolygon(n, t, r, e) {
    t *= .5, r *= .5;
    var a = 2 * Math.PI / n, i = d3.range(n).map(function(n) {
        return [t + (t - e) * Math.sin(n * a), r + (r - e) * -Math.cos(n * a)]
    });
    return i.push(i[0].slice()), i
}
function smallPolygon(n, t) {
    var r          = 10, e = 1, a = regularPolygon(t, 2 * r, 2
        * r, e), i = n.selectAll("svg").data([a]);
    i.enter().append("svg").attr("width", 2 * (r + e)).attr("height", 2 * (r
        + e)).append("path"), i.select("path").attr("d", "M" + a.join("L") + "Z")
}
function powerLaw(n, t, r) {
    ++r;
    var e = Math.pow(n, r), a = Math.pow(t, r);
    return function() {
        return Math.pow((a - e) * Math.random() + e, 1 / r)
    }
}
function polygonArea(n) {
    for(var t = n[0], r = 0, e = 1, a = n.length; a > e; ++e, t = i) {
        var i = n[e];
        r += t[0] * i[1] - t[1] * i[0]
    }
    return .5 * r
}
!function() {
    function n(n, t) {
        var r = n.pop();
        t < n.length && ((n[t] = r).index = t)
    }

    function t(n) {
        return Math.sqrt(r(n, n))
    }

    function r(n, t) {
        return n[0] * t[0] + n[1] * t[1] + n[2] * t[2]
    }

    function e(n, t) {
        return [n[1] * t[2] - n[2] * t[1], n[2] * t[0] - n[0] * t[2], n[0] * t[1] - n[1]
        * t[0]]
    }

    function a(n, t) {
        return [n[0] - t[0], n[1] - t[1], n[2] - t[2]]
    }

    function i(n, t) {
        return r(n.n, t) - r(n.n, n.a.p) > d
    }

    function o(n, t) {
        return Math.abs(r(n.n, t) - r(n.n, n.a.p)) <= d
    }

    function l(n) {
        var r = 1 / t(n);
        return n[0] *= r, n[1] *= r, n[2] *= r, n
    }

    function u(n, t, r) {
        var e;
        this.t = n, this.v = t, this.i = r, this.prevF = null, (e = this.nextF = t.visible)
        && (e.prevF = this), t.visible = this
    }

    function h(n, t, r) {
        i(n, t) && n.visible.push(new u(n, t, r))
    }

    function f(n, t, r) {
        for(var e = t.visible, a = r.visible, i = e.length, o = a.length, l = 0, u = 0; i
        > l || o > u;)if(i > l) {
            var f = e[l];
            if(o > u) {
                var c = a[u];
                if(f.i > c.i) {
                    h(n, c.v, c.i), ++u;
                    continue
                }
                f.i === c.i && ++u
            }
            h(n, f.v, f.i), ++l
        } else {
            var c = a[u];
            h(n, c.v, c.i), ++u
        }
    }

    function c(n, t, r, i) {
        this.visible = [], this.marked = !1, this.n = l(e(a(r, n), a(t, n))), (((this.a = new v(this, n)).next = this.b = new v(this, t)).next = this.c = new v(this, r)).next = this.a, this.index = i
    }

    function v(n, t) {
        this.triangle = n, this.p = t, this.neighbor = this.next = null
    }

    function s(n) {
        return !n.triangle.marked && n.neighbor.triangle.marked
    }

    function p(n) {
        if(!(n = n.neighbor).triangle.marked)for(var t = [n], r = n; ;)if(s(n = n.next)) {
            if(n === r)return t;
            t.push(n)
        } else n = n.neighbor
    }

    function g(n, t) {
        (n.neighbor = t).neighbor = n
    }

    var d = 1e-15;
    d3.geom.nhull = function() {
        function t(t) {
            var r = t.length;
            if(4 > r)return [];
            for(var e = 0; r > e; ++e)t[e].i = e;
            d3.shuffle(t);
            for(var a = t[0], l = t[1], u = t[2], v = new c(a, l, u), e = 3; r > e
            && o(v, t[e]); ++e);
            if(e === r)return [];
            var s = t[e];
            if(t[e] = t[3], t[3] = s, i(v, s)) {
                var d = l;
                l = u, u = d
            }
            var m = new c(a, l, u, 0), b = new c(s, l, a, 1), y = new c(u, s, a, 2), x = new c(l, s, u, 3), w = [m, b, y, x];
            g(m.a, b.b), g(m.b, x.c), g(m.c, y.c), g(b.a, x.a), g(x.b, y.a), g(y.b, b.c);
            for(var e = 4; r > e; ++e) {
                var M = t[e];
                h(m, M, e), h(b, M, e), h(y, M, e), h(x, M, e)
            }
            for(var e = 4; r > e; ++e) {
                var M = t[e], F = M.visible;
                if(F) {
                    var k = null, a = F;
                    do a.t.marked = !0; while(a = a.nextF);
                    a = F;
                    do {
                        var v = a.t;
                        if(k = p(v.a) || p(v.b) || p(v.c))break
                    } while(a = a.nextF);
                    if(k) {
                        for(var P = 0, A = k.length, T = null, j = null; A > P; ++P) {
                            var z = k[P], E = z.triangle, q = z.neighbor.triangle, v = new c(M, z.neighbor.p, z.p, w.length);
                            g(v.b, z), T ? g(T.a, v.c) : j = v, f(v, E, q), w.push(T = v)
                        }
                        g(T.a, j.c), a = F;
                        do {
                            for(var v = a.t, P = 0, A = v.visible.length; A
                            > P; ++P)v.visible[P].remove();
                            v.visible.length = 0, n(w, v.index)
                        } while(a = a.nextF)
                    }
                }
            }
            return w
        }

        return t
    }, u.prototype.remove = function() {
        this.prevF ? this.prevF.nextF = this.nextF : this.v.visible = this.nextF, this.nextF
        && (this.nextF.prevF = this.prevF)
    }
}(),
function() {
    function n(n, r) {
        return r = r || function() {
                return 0
            }, t(n.map(function(n, t) {
            var e = n[0], a = n[1];
            return [e, a, e * e + a * a - r(n, t)]
        })).filter(function(t) {
            t.coordinates = [n[t.a.p.i], n[t.b.p.i], n[t.c.p.i]];
            var r                                 = t.a.p, e = t.b.p, a = t.c.p, i = r[1]
                * (e[2] - a[2]) + e[1] * (a[2]
                - r[2]) + a[1] * (r[2] - e[2]), o = r[2] * (e[0] - a[0]) + e[2]
                * (a[0]
                - r[0]) + a[2] * (r[0] - e[0]), l = r[0] * (e[1] - a[1]) + e[0]
                * (a[1]
                - r[1]) + a[0] * (r[1] - e[1]);
            return t.centre = [-.5 * i / l, -.5 * o / l], !(t.centre.negative = t.n[2]
                >= 0)
        })
    }

    var t = d3.geom.nhull(3);
    d3.geom.power = function(t, r) {
        var e = n(t, r), a = [];
        return e.forEach(function(n) {
            a[n.a.p.i] = n.a, a[n.b.p.i] = n.b
        }), t.map(function(n, t) {
            var r = [], e = r.neighbors = [], i = a[t], o = i, l = o;
            if(!l)return null;
            for(; ;) {
                var u = l.triangle.centre, h = l.neighbor;
                if(u.negative || r.push(u), h.triangle.centre.negative
                    || e.push(h.p.i), l
                    === i && o !== i)break;
                l = (o = l).next.next.neighbor
            }
            return r
        })
    }
}(),
function() {
    function n(n, t, r, i) {
        for(var l = 0, u = t.length - 4; u > l; ++l) {
            var h = n[l];
            if(null != h) {
                var f = o(r, h.slice()), c = t[l];
                if(f) {
                    for(var s = 0, p = 0, g = f[0], d = 0, m = 1, b = f.length; b
                    > m; ++m, g = y) {
                        var y = f[m], x = g[0] * y[1] - y[0] * g[1];
                        s += (g[0] + y[0]) * x, p += (g[1] + y[1]) * x, d += x
                    }
                    if((d *= .5) > v) {
                        var w = 1 / (6 * d);
                        c[0] = s * w, c[1] = p * w
                    }
                    c[2] += i * (c.area - d)
                } else {
                    var M = a(r, e(r));
                    c[0] = M[0], c[1] = M[1], c[2] = c.area
                }
            }
        }
    }

    function t(n) {
        return n[2]
    }

    function r(n, t) {
        for(var r = 1, e = t.length; e > r; ++r) {
            var a = t[r - 1], i = t[r];
            if((i[0] - a[0]) * (n[1] - a[1]) - (i[1] - a[1]) * (n[0] - a[0]) < 0)return !1
        }
        return !0
    }

    function e(n) {
        var t, r, e, a;
        e = a = -(t = r = 1 / 0);
        for(var i = 0, o = n.length; o > i; ++i) {
            var l = n[i], u = l[0], h = l[1];
            t > u && (t = u), u > e && (e = u), r > h && (r = h), h > a && (a = h)
        }
        return [t, r, e, a]
    }

    function a(n, t) {
        var e = t[0], a = t[1], i = t[2], o = t[3], l = 1e4;
        do var u = [e + Math.random() * (i - e), a + Math.random() * (o
        - a)]; while(!r(u, n) && --l);
        if(!l)throw new Error("could not find random point in polygon within 10,000 iterations!");
        return u
    }

    function i(n, t, r, e) {
        var a = r - n, i = e - t;
        return [[n - a, t - i, 0], [r + a, t - i, 0], [n - a, e + i, 0], [r + a, e
        + i, 0]]
    }

    function o(n, t) {
        var r = h(n, t.slice());
        if(r && r.length > 1) {
            var e = r[0], a = r[r.length - 1];
            return (e[0] !== a[0] || e[1] !== a[1]) && r.push(e), r
        }
    }

    function l(n) {
        n.polygon = null;
        var t = n.children;
        t && t.forEach(l)
    }

    function u(n) {
        for(var t = n.length, r = n[0], e = 0, a = 1; t > a; ++a, r = i) {
            var i = n[a];
            e += r[0] * i[1] - r[1] * i[0]
        }
        return .5 * e
    }

    function h(n, t) {
        for(var r = n.length, e = n[--r]; --r >= 0;) {
            var a = t.slice();
            t.length = 0;
            for(var i = n[r], o = a.length, l = a[0], u = 0; ++u < o;) {
                var h = a[u];
                f(h, e, i) ? (f(l, e, i) || t.push(c(l, h, e, i)), t.push(h)) : f(l, e, i)
                && t.push(c(l, h, e, i)), l = h
            }
            t.push(t[0]), e = i
        }
        return t
    }

    function f(n, t, r) {
        return (r[0] - t[0]) * (n[1] - t[1]) < (r[1] - t[1]) * (n[0] - t[0])
    }

    function c(n, t, r, e) {
        var a      = n[0], i = r[0], o = t[0] - a, l = e[0]
            - i, u = n[1], h = r[1], f = t[1] - u, c = e[1] - h, v = (l * (u - h) - c * (a
            - i)) / (c * o - l * f);
        return [a + v * o, u + v * f]
    }

    var v = 1e-15;
    d3.layout.voronoiTreemap = function() {
        function r(n) {
            var t = s(n), r = t[0];
            return r.polygon = v, h(r), t
        }

        function h(r) {
            var v, s = r.children;
            if(s && (v = s.length)) {
                for(var p, g                            = r.polygon, d = r.value, m = e(g), b = u(g), y = s.map(function(n) {
                    var t = n.point;
                    return t || (t = n.point = a(g, m), t.push(b * n.value
                        / d)), t.area = b * n.value / d, t
                }).concat(i(m[0], m[1], m[2], m[3])), x = 0; f
                    > x; ++x)p = d3.geom.power(y, t), n(p, y, g, c);
                for(var x = 0; v > x; ++x) {
                    var w = s[x], M = p[x];
                    M && (w.polygon = o(g, M), w.polygon) ? h(w) : l(w)
                }
            }
        }

        var f = 100, c = .5, v = [[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]], s = d3.layout.hierarchy().sort(null);
        return r.polygon = function(n) {
            return arguments.length ? (v = n, r) : v
        }, r.iterations = function(n) {
            return arguments.length ? (f = +n, r) : f
        }, r.alpha = function(n) {
            return arguments.length ? (c = +n, r) : c
        }, d3.rebind(r, s, "children", "value")
    }
}();
var format = d3.format(".4f");
!function() {
    function n() {
        r = +d3.select("#sides").property("value"), r > 12
        && (r = 120), d3.select("#polygon").call(smallPolygon, r), l.polygon(regularPolygon(r, a, i, 2
            * e)).value(d3.select("#size").property("checked") ? function(n) {
            return n.size
        } : function() {
            return 1
        }), o = !1
    }

    function t(n) {
        var t = l(n).sort(function(n, t) {
                return n.depth - t.depth
            }),
            r = t[0],
            o = polygonArea(r.polygon),
            h = {}, f = 1e-6, m = [];

        g.clearRect(0, 0, a, i);

        for(var b = 0, y = t.length; y > b; ++b) {
            var x = t[b], w = x.polygon;
            if(w) {
                for(var M = w[0], F = Math.round(M[0] / f) * f + "," + Math.round(M[1]
                        / f) * f, k = 1, P = w.length; P > k; ++k, M = A, F = T) {
                    var A = w[k], T = Math.round(A[0] / f) * f + "," + Math.round(A[1]
                            / f) * f, j = (T > F ? F + "," + T : T + "," + F) + ","
                        + x.depth;
                    h[j] = !x.depth || h.hasOwnProperty(j) ? [M, A, x.depth] : null
                }
                if(x.parent && m.push(Math.abs(x.error = polygonArea(w) / o / (x.value
                        / r.value) - 1)), x.children && x.children.length) {
                    var z = w[0];
                    g.beginPath(), g.moveTo(z[0], z[1]);
                    for(var k = 1, P = w.length; P
                    > k; ++k)z = w[k], g.lineTo(z[0], z[1]);
                    g.closePath(), g.fillStyle = u(x.name), g.fill()
                }
            }
        }
        for(var T in h) {
            var E = h[T];
            if(null != E) {
                var q = E[0], C = E[1];
                g.beginPath(), g.moveTo(q[0], q[1]), g.lineTo(C[0], C[1]), g.lineWidth = Math.max(.25, 5
                        - Math.max(1, E[2])) * e, g.stroke()
            }
        }
        var L = d.selectAll("rect").data(p(m));
        return L.enter().append("rect"), L.attr("x", function(n) {
            return v(n.x) + .5
        }).attr("y", function(n) {
            return s(n.y)
        }).attr("width", function(n) {
            return v(n.dx) - 1
        }).attr("height", function(n) {
            return c - s(n.y)
        }), L.exit().remove(), d3.max(m) < .01
    }

    var r,
        e   = window.devicePixelRatio || 1,
        a = 960 * e,
        i = 600 * e, o = !1,
        l = d3.layout.voronoiTreemap().iterations(1);

    d3.format(",f");

    var u = d3.scale.category20c();

    d3.scale.linear().domain([-1, 0, 1])
        .range(["#00f", "#fff", "#f00"]);

    var h                 = {top: 5, right: 8, bottom: 25, left: 25},
        f = 180 - h.right,
        c  = 100 - h.top - h.bottom,
        v = d3.scale.linear().range([0, f]),
        s = d3.scale.linear().range([c, 0]),
        p = d3.layout.histogram().bins(v.ticks(50)).frequency(!1);

    d3.selectAll("#size, #count")
        .on("change", n),
        d3.select("#sides")
            .on("input", n), n();

    var g = d3.select("#chart")
        .append("canvas")
        .attr("width", a)
        .attr("height", i)
        .style("width", a / e + "px")
        .style("height", i / e + "px")
        .node().getContext("2d");

    g.lineCap = "round";
    g.strokeStyle = "#000";
    var d = d3.select("#errors").append("svg")
        .attr("width", f + h.left + h.right)
        .attr("height", c + h.top + h.bottom)
        .style("margin-left", -h.left + "px")
        .append("g")
        .attr("transform", "translate(" + h.left + "," + h.top + ")");

    d.append("g")
        .call(d3.svg.axis().scale(s).ticks(5).orient("left"));
    d.append("g")
            .attr("transform", "translate(0," + c + ")")
            .call(d3.svg.axis().scale(v).ticks(5)), d.append("text")
        .attr("dy", "-.2em")
        .attr("text-anchor", "end")
        .attr("transform", "translate(" + f + "," + c + ")")
        .text("relative error");
    d3.json("flare.json", function(n, r) {
        d3.timer(function() {
            o || (o = t(r))
        })
    })
}();